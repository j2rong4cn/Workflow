From b72aa74a749b83ceec59370292a65bca3538a0e9 Mon Sep 17 00:00:00 2001
From: j2rong4cn <253551464@qq.com>
Date: Fri, 5 Apr 2024 22:02:47 -0400
Subject: [PATCH] support umount modules

---
 kernel/core_hook.c | 52 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 51 insertions(+), 1 deletion(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index fef98df..9b8c922 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -41,6 +41,52 @@
 #include "throne_tracker.h"
 #include "kernel_compat.h"
 
+#include "../../fs/mount.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
+
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+extern inline bool may_mount(void);
+extern inline int check_mnt(struct mount *mnt);
+extern void mntput_no_expire(struct mount *mnt);
+extern int do_umount(struct mount *mnt, int flags);
+static inline bool ksu_path_mounted(const struct path *path)
+	{
+		return path->mnt->mnt_root == path->dentry;
+	}
+	static int ksu_can_umount(const struct path *path, int flags)
+	{
+		struct mount *mnt = real_mount(path->mnt);
+
+		if (!may_mount())
+			return -EPERM;
+		if (!ksu_path_mounted(path))
+			return -EINVAL;
+		if (!check_mnt(mnt))
+			return -EINVAL;
+		if (mnt->mnt.mnt_flags & MNT_LOCKED) /* Check optimistically */
+			return -EINVAL;
+		if (flags & MNT_FORCE && !capable(CAP_SYS_ADMIN))
+			return -EPERM;
+		return 0;
+	}
+	int ksu_path_umount(struct path *path, int flags)
+{
+	struct mount *mnt = real_mount(path->mnt);
+	int ret;
+
+	ret = ksu_can_umount(path, flags);
+	if (!ret)
+		ret = do_umount(mnt, flags);
+
+	/* we mustn't call path_put() as that would clear mnt_expiry_mark */
+	dput(path->dentry);
+	mntput_no_expire(mnt);
+	return ret;
+}
+#else
+	//not tested
+#endif
 static bool ksu_module_mounted = false;
 
 extern int handle_sepolicy(unsigned long arg3, void __user *arg4);
@@ -440,12 +486,16 @@ static bool should_umount(struct path *path)
 
 static int ksu_umount_mnt(struct path *path, int flags)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0) || defined(KSU_UMOUNT)
+#if defined(KSU_UMOUNT)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
 	return path_umount(path, flags);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+	return ksu_path_umount(path, flags);
 #else
 	// TODO: umount for non GKI kernel
 	return -ENOSYS;
 #endif
+#endif
 }
 
 static void try_umount(const char *mnt, bool check_mnt, int flags)
-- 
2.30.2

